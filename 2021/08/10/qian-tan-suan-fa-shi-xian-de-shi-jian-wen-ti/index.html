<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zypc-1903.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":12,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="作者 &#x2F; 190310 方梓轩  一 绪论同学们可能很疑惑，为什么有人做事总比我快一点？ 我们收获的绝大多数答案是“这个人做事就是快”这种没有任何参考意义的答案，其他时候，稍微有一点营养的回答“因为他用了更高效的方法”。 但是，我们关心的是，什么样的方法是高效的？ 本文以斐波那契求值问题、数列排序问题为例，简单探究算法实现的时间问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈算法实现的时间问题">
<meta property="og:url" content="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/index.html">
<meta property="og:site_name" content="1903">
<meta property="og:description" content="作者 &#x2F; 190310 方梓轩  一 绪论同学们可能很疑惑，为什么有人做事总比我快一点？ 我们收获的绝大多数答案是“这个人做事就是快”这种没有任何参考意义的答案，其他时候，稍微有一点营养的回答“因为他用了更高效的方法”。 但是，我们关心的是，什么样的方法是高效的？ 本文以斐波那契求值问题、数列排序问题为例，简单探究算法实现的时间问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/graph1.png">
<meta property="og:image" content="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/mergesort.png">
<meta property="article:published_time" content="2021-08-10T10:15:45.000Z">
<meta property="article:modified_time" content="2021-08-13T13:35:48.552Z">
<meta property="article:author" content="1903">
<meta property="article:tag" content="巨佬谭">
<meta property="article:tag" content="第二期">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/graph1.png">

<link rel="canonical" href="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>浅谈算法实现的时间问题 | 1903</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">1903</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zypc-1903.github.io/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="1903">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="1903">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅谈算法实现的时间问题
        </h1>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-10 18:15:45" itemprop="dateCreated datePublished" datetime="2021-08-10T18:15:45+08:00">2021-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-13 21:35:48" itemprop="dateModified" datetime="2021-08-13T21:35:48+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>作者</strong> / 190310 方梓轩</p>
<hr>
<h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一 绪论"></a>一 绪论</h2><p>同学们可能很疑惑，为什么有人做事总比我快一点？</p>
<p>我们收获的绝大多数答案是“这个人做事就是快”这种没有任何参考意义的答案，其他时候，稍微有一点营养的回答“因为他用了更高效的方法”。</p>
<p>但是，我们关心的是，什么样的方法是高效的？</p>
<p>本文以<strong>斐波那契求值问题</strong>、<strong>数列排序问题</strong>为例，简单探究算法实现的时间问题。</p>
<span id="more"></span>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=865964850&auto=1&height=66"></iframe>

<p>以<strong>斐波那契求值问题</strong>为例，我们将探究<strong>递归</strong>思想、<strong>递推</strong>思想以及<strong>矩阵加速</strong>思想，其中，我们会简单探究<strong>快速幂问题</strong>。探究 $O(n^2)\to O(n) \to O(\log n)$ 的时间复杂度优化。其中前二者思维难度较低，相信对大家没有理解难度。第三者有线性代数知识，属于高中内容，但所涉不深，理解难度也不高，如果有兴趣建议阅读。</p>
<p>以<strong>数列排序问题</strong>为例，我们将探究<strong>选择排序</strong>思想、<strong>冒泡排序</strong>思想、<strong>堆排序</strong>思想、<strong>归并排序</strong>思想以及<strong>计数排序</strong>思想。探究 $O(n^2) \to O(n\log n)\to O(n+w)$ 的时间复杂度优化。都是很简单的思想，属于信竞生入门必备通识，相信理解其思想对大家没有难度。</p>
<p>以上这些奇奇怪怪的名词和符号看不懂也没关系，不影响理解，<del>只影响装X</del></p>
<h2 id="二-斐波那契数列"><a href="#二-斐波那契数列" class="headerlink" title="二 斐波那契数列"></a>二 斐波那契数列</h2><h3 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h3><script type="math/tex; mode=display">
\begin{equation}
 a_n=
 \begin{cases}
  n & n\le 1 \\
  a_{n-1}+a_{n-2} & n >1
 \end{cases}
 \ \ \ \ \ \forall n\in \mathbf{Z^+}
\end{equation}</script><p>这是我们熟悉的斐波那契数列。</p>
<p>现在 fzx 想要知道，斐波那契数列的第 $n$ 项是多少，更形式地说，$a_n$ 的值是多少。</p>
<p>因为要知道 $a_n$ 的值必须要知道 $a_{n-1},a_{n-2}$ 的值，我们很容易想到不负责任地找 fzx 要 $a_{n-1},a_{n-2}$ 的值。</p>
<p>然后 fzx 又反过来问 $a_{n-1},a_{n-2}$ 的值是多少，我们又要探究 $a_{n-2},a_{n-3},a_{n-4}$ 的值……直到 $a_{n-m}$ 小于 2，我们可以直接知道 $a_{n-m}=n-m$，然后再一个个加起来。</p>
<p>但是这样非常费时费力，比如我们想知道 $a_5$ 的值，就要先知道 $a_4,a_3$，然后要问 $a_3,a_2,a_1$，$a_1=1$，所以又要问 $a_2,a_1,a_0$，然后又要问 $a_1,a_0$。</p>
<p>对于每一个 $a_n$ 被询问的次数，我们列一个表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">自变量值</th>
<th style="text-align:center">5</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">询问次数</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p>加起来，为了求 $a_5$ 的值，我们询问了 15 次。</p>
<p>更抽象地，我们假设一次询问需要单位1的时间，设求出 $a_x$ 所需要的时间为 $T(x)$，我们发现，当 $x\le 1$ 时，$T(x)=1$，当 $x \ge 2$ 时，$T(x)=T(x-1)+T(x-2)+1$，一样地我们列一个表格。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$T(x)$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
<td style="text-align:center">15</td>
<td style="text-align:center">25</td>
<td style="text-align:center">41</td>
<td style="text-align:center">67</td>
<td style="text-align:center">109</td>
<td style="text-align:center">177</td>
</tr>
</tbody>
</table>
</div>
<p>增长速度非常恐怖。</p>
<p>事实上 $T(x)=T(x-1)+T(x-2)+1$，我们可以近似地看成 $T(x)=2T(x-1)+1$，和$T(x)=x^2$ 非常接近，甚至可以看见，在 $x$ 比较大的时候，$T(x)$ 甚至比 $x^2$ 还要大。</p>
<p>用这种笨方法，为了求 $f(x)$ 的值，我们用了超过 $x^2$ 的时间。事实上，可以证明，$T(x)\approx a_x$，也就是说，$T(x)$ 的增长速度与斐波那契数的增长速度相近。</p>
<h3 id="2-2-递推"><a href="#2-2-递推" class="headerlink" title="2.2 递推"></a>2.2 递推</h3><p>有没有更快的方法呢？</p>
<p>当然有，根据数列定义式，我们知道 $a_0,a_1$ 即可直接算出 $a_2$，我们知道 $a_1,a_2$ 即可直接算出 $a_3$ …… 所以，我们为什么不把我们已经求出来的数给记下来呢？</p>
<p>这里不列表格了，我们直接研究 $T(x)$，当 $x&lt;2$ 时，$T(x)=1$，当 $x \ge 2$ 时，$T(x)=T(x-1)+1$，因为我们可以直接由记下来的 $a_{x-2},a_{x-1}$ 求出 $a_x$，不难发现 $T(x)=x$，我们用 $x$ 的时间就完成了 $a_x$ 的求值，比递归思想快 $\dfrac{a_x}{x}$ 倍，在 $x$ 的值一般少则几千，大则千万的时候，这样的优化是非常恐怖的，非常值得欣慰。</p>
<h3 id="2-3-矩阵加速"><a href="#2-3-矩阵加速" class="headerlink" title="2.3 矩阵加速"></a>2.3 矩阵加速</h3><p><strong>阅前须知：本小节有线性代数知识，属于高中知识，但所涉不深，理解难度不高，如果有兴趣建议阅读。</strong></p>
<h4 id="2-3-1-矩阵乘法"><a href="#2-3-1-矩阵乘法" class="headerlink" title="2.3.1 矩阵乘法"></a>2.3.1 矩阵乘法</h4><p>矩阵，很形象地就是个矩阵，$n \times m$ 的矩阵就是个 $n$ 行 $m$ 列的数字构成的矩形方阵。它大概长这个样子：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots & a_{1,m} \\
a_{2,1} & a_{2,2} & \cdots & a_{2,m} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n,1} & a_{n,2} & \cdots & a_{n,m} \\
\end{bmatrix}</script><p>如果矩阵的名字为 $A$，它第 $i$ 行第 $j$ 列的元素被称为 $a_{i,j}$。</p>
<p>两个矩阵相乘，当且仅当前一个矩阵的列数与后一个矩阵的行数相同是才有意义，具体原因见下。</p>
<p>设一个 $n\times m$ 的矩阵 $A$ 和 $m\times p$ 的矩阵 $B$ 之积为 $n\times p$ 的矩阵 $C$，则有</p>
<script type="math/tex; mode=display">
\begin{equation}
C_{i,j}=\sum_{k=1}^m A_{i,k}\times B_{k,j}
\end{equation}</script><p>看不懂或者看不明白没关系，以上式子的意思是：$C$ 的第 $i$ 行第 $j$ 列的数，由 $A$ 的第 $i$ 行每一个数和 $B$ 的第 $j$ 列每一个数分别相乘得到。</p>
<h4 id="2-3-2-快速幂"><a href="#2-3-2-快速幂" class="headerlink" title="2.3.2 快速幂"></a>2.3.2 快速幂</h4><p>现在 fzx 告诉你两个实数 $a,b$，他想要知道 $a^b$ 是多少，我们该怎么办。</p>
<p>最简单的方法是将 1 连续乘 $b$ 次 $a$。</p>
<p>但是次次乘 $a$，总感觉有点亏，容易想到把 $a$ 先弄个平方，然后只需要乘 $\dfrac{b}{2}$ 次了，这样节省了一半的时间。（ $b$ 为奇数的情况应当特殊处理一下，当然这种处理自然到不需特别赘述，因此我们以下省略对这种情况的讨论）</p>
<p>还是有点亏，我们算出来 $a^4$，还只要四分之一的时间呢。</p>
<p>但是如果 $b$ 扩大到原来的两倍、四倍、甚至八倍，我们的小心机就没什么用了。</p>
<p>容易发现我们上面利用的是 $a^b=a^{\frac{b}{2}}\times a^{\frac{b}{2}}$ 的性质，如果我们知道后者就可以在 1 的时间内求出前者了，那我们用递归求斐波那契的套路，再问 fzx 要 $a^{\frac{b}{2}}$ 的值……直到 $\frac{b}{x}=1$的时候，我们可以直接知道这个值为 $a$。就比如，</p>
<script type="math/tex; mode=display">
a^{173}=a^{128}\times a^{32}\times a^{8}\times a^{4}\times a</script><p>而 $a^4,a^8,a^{32},a^{128}$ 都可以通过 “滚雪球” 的方式不断让 $a$ 倍乘得到。</p>
<p>还是用 $T(x)$ 来定义求出这玩意的时间，假设我们每次乘法的时间是固定为 1 单位时间的，因此我们并不关心 $a$ 而只关心 $b$。</p>
<p>显然我们有 $T(x)=T(\dfrac{x}{2})+1$。在高中我们会学到<strong>对数</strong>，其中之一定义式是 $x=2^{\log_2x}$，比如 $2^5=32$，所以 $\log_2 32=5$。对数增长得很慢，我们具体就不列表格了，具体感受一下诸如 $\log_2 32768=15,\log_2 2147364848=31$ 之类的就可以了。</p>
<p>我们不难发现 $T(x)=\log x$，于是我们在非常出色的时间内完成了 $a^b$ 的计算。</p>
<h4 id="2-3-3-base-的推导"><a href="#2-3-3-base-的推导" class="headerlink" title="2.3.3 base 的推导"></a>2.3.3 base 的推导</h4><p>我们记 $F(x)$ 为一个矩阵 $\begin{bmatrix} a_x  a_{x-1} \end{bmatrix}$，显然我们要知道 $a_x$ 的值，取 $F(x)$ 的第一行第一列就可以了。</p>
<p>现在我们期望有一个矩阵 $\text{base}$，使得 $F(x) \times \text{base} = F(x+1)$。首先这个矩阵得是两行两列的。然后我们再慢慢确定每一个值。<br>首先 $F(x+1)$ 的第一行第一列应该是 $a_{x+1} = 1 \times a_x+ 1 \times a_{x-1}$，利用矩阵乘法的性质我们很容易知道 $\text{base}$ 的第一列全部都是 1。<br>然后 $F(x+1)$ 的第一行第二列应该是 $a_x = 1 \times a_x+ 0 \times a_{x-1}$，我们如法炮制，得出 $\text{base}$ 的第二列为 $1,0$。<br>即有 $\text{base}=\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}$。</p>
<h4 id="2-3-4-快速幂优化矩阵乘法"><a href="#2-3-4-快速幂优化矩阵乘法" class="headerlink" title="2.3.4 快速幂优化矩阵乘法"></a>2.3.4 快速幂优化矩阵乘法</h4><p>我为什么要把快速幂和矩阵乘法放在一起讲呢？是的，矩阵乘法也可以快速幂。</p>
<p>因为矩阵乘法的其实就是一堆东西相乘，对于一个矩阵 $A$，其依然满足 $A^b=A^{\frac{b}{2}}\times A^{\frac{b}{2}}$。</p>
<h4 id="2-3-5-矩阵加速递推"><a href="#2-3-5-矩阵加速递推" class="headerlink" title="2.3.5 矩阵加速递推"></a>2.3.5 矩阵加速递推</h4><p>于是我们有 $F(2) \times \text{base} = F(3),F(3) \times \text{base}=F(4),F(4) \times \text{base}=F(5)$ ……<br>故可以得出 $F(x) = F(2) \times \text{base}^{x-2}$。使用快速幂计算 $\text{base}^{x-2}$。<br>考察 $T(x)$ 的值，不难发现 $T(x)=\log x$。</p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>到这里，我们考察了 $T(x)=x^2$ 的<strong>递归</strong>算法，$T(x)=x$ 的<strong>递推</strong>算法和 $T(x)=\log x$的<strong>矩阵乘法</strong>算法。</p>
<p>我们列一个表格，试着探讨这些算法的速度差距。以下采用一些可以接受的近似值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$ 的值</th>
<th>递归 $T(x)$</th>
<th>递推 $T(x)$</th>
<th>矩阵乘法 $T(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$10$</td>
<td>$55$</td>
<td>$10$</td>
<td>$\approx 3$</td>
</tr>
<tr>
<td>$100$</td>
<td>$\approx 3.54\times 10^{20}$</td>
<td>$100$</td>
<td>$\approx 7$</td>
</tr>
<tr>
<td>$10^3$</td>
<td>$\approx 4.34\times 10^{208}$</td>
<td>$10^3$</td>
<td>$\approx 10$</td>
</tr>
<tr>
<td>$10^5$</td>
<td>$\approx 2.59\times 10^{20898}$</td>
<td>$10^5$</td>
<td>$\approx 17$</td>
</tr>
<tr>
<td>$10^7$</td>
<td>$\approx 1.12\times 10^{2089876}$</td>
<td>$10^7$</td>
<td>$\approx 23$</td>
</tr>
<tr>
<td>$10^9$</td>
<td>$\approx 10^{10^8}$</td>
<td>$10^9$</td>
<td>$\approx 30$</td>
</tr>
<tr>
<td>$10^{18}$</td>
<td>$\approx 10^{10^{16}}$</td>
<td>$10^{18}$</td>
<td>$\approx 60$</td>
</tr>
</tbody>
</table>
</div>
<p>数据越大差距越明显。</p>
<p><strong>特别提醒</strong>：在重要考试中，请勿使用快速幂优化人工计算，否则后果自负。</p>
<h2 id="三-数列排序问题"><a href="#三-数列排序问题" class="headerlink" title="三 数列排序问题"></a>三 数列排序问题</h2><h3 id="3-1-选择排序和冒泡排序思想"><a href="#3-1-选择排序和冒泡排序思想" class="headerlink" title="3.1 选择排序和冒泡排序思想"></a>3.1 选择排序和冒泡排序思想</h3><p>现在我们要对一个数列进行排序，一般是从小到大或者从大到小，我们会怎么样排序？<br>我们首先介绍两种极其直观的排序思想。<br>首先我们需要一个例子，那么我们随便写一个数列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 5</span><br></pre></td></tr></table></figure>
<p>我们首先盯着第一个数，即 4。然后往后看，发现 1 是最小的，交换，原数列变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 2 4 5</span><br></pre></td></tr></table></figure>
<p>紧接着我们盯着第二个数，即 3，然后往后看，发现 2 是最小的，交换，原数列排序完成。</p>
<p>我们盯着第一个数，然后往后找，找到最小的，然后与第一个数交换，这样我们可以确保第 1 个数是第 $1\sim n$ 个数中最小，也即所有数中最小，即第一小的。</p>
<p>具体地，对于一个 $n$ 个数的数列，我们每次看着第 $i$ 个数，可以确定交换后第 $i$ 个数是 第 $i$ 到 $n$ 个数中最小的。当我们看到第 $i$ 个数时，暗含了我们已经确定了第一到第 $i-1$ 小的数，所以我们只需要往后找就是了。我们看到第 $i$ 个数时，比较了 $n-i+1$ 次，把所有 $n-i+1$ 相加，即 $T(n)=\dfrac{n(n+1)}{2}$，可以近似地看成 $T(n)=n^2$。</p>
<p>冒泡排序跟选择排序很像，但依然有所不同。还是那个数列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 5</span><br></pre></td></tr></table></figure>
<p>首先比较 4 和 3，发现 $4&gt;3$，交换，变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 1 5</span><br></pre></td></tr></table></figure>
<p>然后比较 4 和 2，发现 $4&gt;2$，交换，变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2 4 1 5</span><br></pre></td></tr></table></figure>
<p>交换 4 和 1，变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2 1 4 5</span><br></pre></td></tr></table></figure>
<p>比较 4 和 5，发现 $4&lt;5$ ，不交换。如此跑五趟，即可排序完成</p>
<p>我们把每一个数字比作水里的气泡，大的数字快速往后交换、小的数字慢慢往前交换的样子就像气泡上浮下沉的样子，所以叫冒泡排序。<br>容易发现，第 $i$ 趟交换能确定第 $i$ 大的数字，$n$ 次交换就能排序完成。<br>我们使用和选择排序一样的计算方法，容易得出冒泡排序的时间也是 $T(n)=n^2$ 的。</p>
<h3 id="3-2-堆排序思想"><a href="#3-2-堆排序思想" class="headerlink" title="3.2 堆排序思想"></a>3.2 堆排序思想</h3><p>当然还有一种很直观的想法是，每次取出数列中最小的一个数，放进另一个数列里，直到原数列取完，新数列也就是排序之后的数列了。</p>
<p>当然这样基本同选择排序无异，时间依然是 $T(n)=n^2$ 的。这里我们要引入二叉堆这样一个概念。</p>
<h4 id="3-2-1-二叉堆"><a href="#3-2-1-二叉堆" class="headerlink" title="3.2.1 二叉堆"></a>3.2.1 二叉堆</h4><p>相信大家都画过一棵树一样的东西，它大概长这样</p>
<p><img src="/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/graph1.png" alt="graph1" style="zoom:50%;"></p>
<p>为了方便称呼，我们说 1 是 2 和 3 的父亲，相应地 2 和 3 是 1 的儿子。2 4 5 和 3 6 7 的关系同理。</p>
<p>我们会发现，父亲的结点上的值总是小于儿子结点的值——所以所有点的祖宗，在这里是 1 节点的值就是所有点中最小的。</p>
<p>而我们如果要加入一个点呢？假设我们要加入一个值 1.5。首先把他放在 3 的儿子处，然后我们发现 3 大于 1.5，把他们交换。因为二叉堆的性质，3 上面肯定没有比他更大的值，所以他不可能再往上走，于是他就只能往下走，而兄弟之间是无所谓大小关系的，所以可以让 1.5 变成他们的父亲，而 3 变成他们的儿子。删除最小值同理，逆向操作即可。</p>
<p>虽然听起来怪怪的，但如果我们分析一下，会发现加入一个点，并将其放到合理的地方，以及取出最小值，把这个二叉堆变成合理的样子，每次操作所需要的的时间是这棵二叉树的深度，也就是 $\log n$ ，$n$ 代表二叉堆上结点总数，如果加入 $n$ 个节点并查询 $n$ 次最小值的话，其时间是 $T(n)=n \log n$ 的。优于选择排序和冒泡排序。</p>
<h3 id="3-3-归并排序思想"><a href="#3-3-归并排序思想" class="headerlink" title="3.3 归并排序思想"></a>3.3 归并排序思想</h3><h4 id="3-3-1-有序数列合并"><a href="#3-3-1-有序数列合并" class="headerlink" title="3.3.1 有序数列合并"></a>3.3.1 有序数列合并</h4><p>现在我们有两个数列，他们都是递增的。举个例子 1 3 5 7 9 和 2 4 6 8 10。</p>
<p>我们要把他们合并起来，首先确定，在这两个数列中，任何一段连续的部分，最前面的数字肯定是这一部分里最小的。我们关心两个数列中最小的，即我们关心两个数列最前面两个数中较小的。</p>
<p>首先比较 1 和 2，发现 $1&lt;2$，则把 1 放进新数列中，然后比较 2 和 3，发现 $2&lt;3$ ，把 2 放进新数列中，然后比较 3 和 4，发现 $3&lt;4$，把3放进新数列中……</p>
<p>十次比较，十次插入，我们就能得到长度为 10 的数列。</p>
<p>因此我们可以得到，有序数列合并的时间是 $T(n)=n$ 的。取出数的操作很像两个指针指在两个序列的开头，向右慢慢移动并比较的过程，所以这种方法也叫双指针法。</p>
<h4 id="3-3-2-归并排序"><a href="#3-3-2-归并排序" class="headerlink" title="3.3.2 归并排序"></a>3.3.2 归并排序</h4><p>为什么选择排序和冒泡排序慢，因为确定第 $i$ 大的时候，作了 $n$ 次比较。</p>
<p>如果我们把数列缩小到原来的一半，那总比较次数就变成了原来的四分之一……</p>
<p>我们要试一下，这样能不能让我们像快速幂一样，把 $T(n)=n$ 变成 $T(n)=\log n$。</p>
<p>考虑将一个数列中间切开，然后我们将这两个小数列分别排序，当他们有序，我们就只要 $O(n)$ 的时间将他们合并。直到一个数列只有两个数字，一次比较即可排好序。</p>
<p>然后是两个长度为 2 的数列，我们用 <strong>3.3.1 有序数列合并 </strong>中的方法将他们合并。整个合并的过程就像这样：</p>
<p><img src="/2021/08/10/qian-tan-suan-fa-shi-xian-de-shi-jian-wen-ti/mergesort.png" alt="mergesort" style="zoom:50%;"></p>
<p>容易得出 $T(n)=2T(\dfrac{n}{2})+n$，也可以近似看成 $T(n)=n \log n$。简要证明一下：每一层数列分成相等的两部分，所以总层数是 $\log n$。又由于每一层的总时间为 $n$，所以 $T(n)=n\log n$。</p>
<h3 id="3-4-计数排序思想"><a href="#3-4-计数排序思想" class="headerlink" title="3.4 计数排序思想"></a>3.4 计数排序思想</h3><p>还有一种不基于比较的排序方法，可能会给人一种 ”这也可以？“ 的感觉。</p>
<p>比如，我们有如下长度为 10 的数列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 5 4 3 3 2 7 5 6 2</span><br></pre></td></tr></table></figure>
<p>我们扫描一遍原数列，记录下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数字</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">出现次数</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>于是可以得到排序后的数列：2 个 2，2 个 3，1 个 4，3 个 5，1 个 6，1个 7，也就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 3 3 4 5 5 5 6 7</span><br></pre></td></tr></table></figure>
<p>他的时间是 $T(n)=n+w$，其中 $w$ 为要排序的数中的极差（最大值减去最小值）。</p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>到这里，我们考察了 $T(n)=n^2$ 的<strong>选择排序</strong>和<strong>冒泡排序</strong>、$T(n)=n \log n$ 的<strong>堆排序</strong>和<strong>归并排序</strong>，以及 $T(n)=n+w$ 的<strong>计数排序</strong>。</p>
<p>事实上，排序的方法非常之多，还有很多排序：插入排序、快速排序、基数排序、希尔排序等等等等，这里只是介绍几个典型的排序方法。相信大家在斐波那契求值问题已经领略到了当数据规模十分庞大时，速度不同的算法所用时间的差异有多么恐怖，这里不再列表。</p>
<p><strong>特别提醒</strong>：在重要考试中，请勿贸然、刻意使用上文中提到的排序方法，否则后果自负。计数排序仅限于要排序的数范围不大的时候。</p>
<h2 id="四-练习题"><a href="#四-练习题" class="headerlink" title="四 练习题"></a>四 练习题</h2><p><strong>1</strong> / 如果 $T(n)=n+\dfrac{n}{2}+\dfrac{n}{3}+\cdots +\dfrac{n}{n-1}+1$，证明 $T(n)\approx n\log n$。</p>
<p><strong>2</strong> / 如果 $T(n)=2T(\dfrac{n}{2})+n\log n$，证明 $T(n)\approx n\log^2 n$。</p>
<p><strong>3</strong> / 如果 $T(n)=4T(\dfrac{n}{2})+n$，证明 $T(n)\approx n^2$。</p>
<p><strong>4</strong> / 证明斐波那契数列递归法的 $T(n)=a_n$。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>笔者学术水平有限，所知甚少，在保证语言通俗易懂的同时难免失表达的严谨，在如此长文中难免犯事实性错误。</p>
<p>由于写作时间紧促，其中有一些推导没有详细展开，相信读者自证不难，如果有不能理解的地方，欢迎来找笔者讨论。解决一个问题有很多方法。信息学竞赛的一大核心就是使用更高效率的方法解决问题，以上探讨的仅仅是冰山一角，两个浅而显的典型。</p>
<p>当然，最好的方法永远是自己的方法，以上算法只是分享给大家，请不要在考试中贸然、刻意使用这些方法，这些方法有的并不是很契合人脑计算，有的对小规模数据没有明显优势，而且尝试新方法时，速度慢、易出错。同时，sxh 同学为这篇文章补充了一些简洁的证明、修正了一些错误以及增加了练习题部分，在这里向他致以诚挚的感谢。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B7%A8%E4%BD%AC%E8%B0%AD/" rel="tag"># 巨佬谭</a>
              <a href="/tags/%E7%AC%AC%E4%BA%8C%E6%9C%9F/" rel="tag"># 第二期</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/21/xuan-xue-de-xiu-yang-zhi-dao/" rel="prev" title="玄学的修养之道">
      <i class="fa fa-chevron-left"></i> 玄学的修养之道
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/10/test/" rel="next" title="你 被 骗 了">
      你 被 骗 了 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzczMy8zMDIwNg=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">一 绪论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">二 斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%80%92%E5%BD%92"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%80%92%E6%8E%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 递推</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 矩阵加速</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 矩阵乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-base-%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 base 的推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 快速幂优化矩阵乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E9%80%92%E6%8E%A8"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5 矩阵加速递推</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E6%95%B0%E5%88%97%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">三 数列排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 选择排序和冒泡排序思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A0%86%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 堆排序思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 二叉堆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 归并排序思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%9C%89%E5%BA%8F%E6%95%B0%E5%88%97%E5%90%88%E5%B9%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 有序数列合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 归并排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 计数排序思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">四 练习题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">五 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">1903</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">1903</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
